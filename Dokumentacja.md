# Bazy danych 2 Projekt
# Stas Kochevenko, Wiktor Dybalski

## 1. **Opis projektu**

W ramach projektu została stworzona strona kina z możliwością rejestracji, logowania się na stronie, rezerwacją i zakupem biletów na dostępne seansy. Wybrane przez nas technologie: PostgreSQL (baza danych), ReactJS (frontend), Django (backend).

## 2. **Schemat bazy danych**

![dbschema](img/schema.png)

Dany schemat przedstawia podstawowe encji, niezbędne do poprawnego działania strony kina. Do uproszczenia modelu bazy danych przyjęliśmy kilka zasad:

-- Kino posiada tylko jedną lokalizację
-- Wszystkie filmy są przydzielone tylko jednej kategorii, posiadają tylko jednego reżysera
-- Seansy filmów odbywają się w salach (1-6), przy czym każda sala posiada taką samą liczbę miejsc (84), chociaż to zawsze można zmienić
-- Bilety na seans mają dwie ceny: Standard & Premium. Premium-bilet odpowiada ostatniemu rzędu w kinie, czyli miejscam 1-11
-- Klienci mogą jak kupować, tak i rezerwować bilety na określone miejsca. W przypadku rezerwacji w profilu oni mają możliwość kupienia danego biletu albo jego anulowania
-- Każdy bilet posiada status. Istnieją 3 opcję tego statusu: "New" - nowy nieopłacony bilet (rezerwacja), "Confirmed" - opłacony bilet (nie da się jego anulować), "Canceled" - anulowany bilet
-- Tabela Tickets posiada redundantne pole "MovieScreeningID", do którego można by było się dostać poprzez wykonanie kilku opercaji łączenia tabel, ale takie podejście byłoby mniej efektywne, ponieważ możliwe że często będziemy potrzebować tej informacji
-- Na stronie ustawiliśmy datę 22-05-2024 oraz czas 13-00, który jest "aktualnym" czasem przeglądania strony. To jest umotywowane tym, że filmy i seansy są przyznaczone na określone daty, więc niezmienna data była wygodna do testowania poprawności działania systemu i bazy danych
-- Nie udało się zrealizować utworzenia sesji użytkownika na froncie (mimo, że logowanie i rejestracja na poziomie backendu i bazy danych działają poprawnie), więc na stronie ustawiliśmy użytkownika domyślnego i ID = 6

## 3. **Tabele**

- user_api_app_user

Tabela została wygenerowana przez django, połączyliśmy ją z tabelą Tickets

```postgresql
create table user_api_appuser
(
    password     varchar(128) not null,
    last_login   timestamp with time zone,
    is_superuser boolean      not null,
    user_id      integer generated by default as identity
        primary key,
    email        varchar(50)  not null
        unique,
    username     varchar(50)  not null,
    is_active    boolean      not null,
    is_staff     boolean      not null
);

alter table user_api_appuser
    owner to postgres;

create index user_api_appuser_email_8e98cebd_like
    on user_api_appuser (email varchar_pattern_ops);
```

![user_api_app_user](img/1.png)

- movie_categories

```postgresql
create table movie_categories
(
    moviecategoryid integer default nextval('moviecategories_moviecategoryid_seq'::regclass) not null
        constraint moviecategories_pk
            primary key,
    categoryname    varchar(40)                                                              not null
);

alter table movie_categories
    owner to postgres;
```

![movie_categories](img/2.png)

- movies

```postgresql
create table movies
(
    movieid          serial
        constraint movies_pk
            primary key,
    moviecategoryid  integer          not null
        constraint product_category_product
            references movie_categories,
    title            varchar(40)      not null,
    startdate        date             not null,
    enddate          date             not null,
    duration         integer          not null,
    description      varchar(255)     not null,
    image            bytea            not null,
    director         varchar(40)      not null,
    minage           integer          not null,
    production       varchar(40)      not null,
    originallanguage varchar(40)      not null,
    rank             double precision not null
);

alter table movies
    owner to postgres;
```

![movies](img/3.png)

- movie_halls

Może się wydawać, że wystarczyło by samo ID, ale biezpieczniej mieć osobną kolumnę, bo w przypadku usunięcia kolejny ID będzie coraz większy

```postgresql
create table movie_halls
(
    moviehallid serial
        primary key,
    hall_number integer not null
        constraint movie_halls_hall_number_unique
            unique
);

alter table movie_halls
    owner to postgres;
```

![movie_halls](img/4.png)

- movie_screening

Tabela przedstawia konkretny seans filmu

```postgresql
create table movie_screening
(
    moviescreeningid serial
        constraint movie_screening_pk
            primary key,
    movieid          integer        not null
        constraint session_movies
            references movies,
    date             date           not null,
    starttime        time           not null,
    endtime          time           not null,
    pricestandard    numeric(12, 2) not null,
    pricepremium     numeric(12, 2) not null,
    threedimensional boolean        not null,
    language         varchar(40)    not null,
    hallnumber       integer        not null
        constraint hallnumber
            references movie_halls (hall_number)
);

alter table movie_screening
    owner to postgres;
```

![movie_screening](img/5.png)

- hall_seats

```postgresql
create table hall_seats
(
    seatid          serial
        constraint hall_seats_pk
            primary key,
    seatnumber      integer not null,
    moviehallnumber integer not null
        constraint hallseats_moviehalls
            references movie_halls (hall_number)
);

alter table hall_seats
    owner to postgres;
```

![hall_seats](img/6.png)

- tickets

```postgresql
create table tickets
(
    ticketid         integer default nextval('tickets_tickedid_seq'::regclass) not null
        constraint tickets_pk
            primary key,
    customerid       integer                                                   not null
        constraint client_purchase
            references user_api_appuser,
    orderedondate    date                                                      not null,
    orderedontime    time                                                      not null,
    status           char(10)                                                  not null,
    moviescreeningid integer                                                   not null
        constraint tickets_moviescreening
            references movie_screening,
    seatnumber       integer                                                   not null
        constraint tickets_hallseats
            references hall_seats
);

alter table tickets
    owner to postgres;
```

![tickets](img/7.png)

- triger validate_reservation_time

```postgresql
create trigger validate_reservation_time
    before insert
    on tickets
    for each row
execute procedure check_reservation_period();
```

## 4. **Widoki**

- Wyświetlenie danych o wszystkich zajętych miejscach na określony seans

```postgresql
reate view occupied_seats(id, seatnumber, hallnumber, moviescreeningid) as
SELECT row_number() OVER (ORDER BY tickets.moviescreeningid, tickets.seatnumber) AS id,
       tickets.seatnumber,
       movie_screening.hallnumber,
       tickets.moviescreeningid
FROM tickets
         JOIN movie_screening ON tickets.moviescreeningid = movie_screening.moviescreeningid;

alter table occupied_seats
    owner to postgres;
```

![](img/8.png)

- Średnia cena biletu (standardowa i premium) dla danej kategorii wraz z liczbą seansów w okresie +- 6 miesięcy

```postgresql
create view average_ticket_prices_by_category
            (categoryname, moviescreenings_amount, average_pricestandard, average_pricepremium) as
SELECT mc.categoryname,
       count(ms.moviescreeningid)                                                         AS moviescreenings_amount,
       round(COALESCE(sum(ms.pricestandard) / count(ms.movieid)::numeric, 0::numeric), 2) AS average_pricestandard,
       round(COALESCE(sum(ms.pricepremium) / count(ms.movieid)::numeric, 0::numeric), 2)  AS average_pricepremium
FROM movie_categories mc
         LEFT JOIN movies m ON mc.moviecategoryid = m.moviecategoryid
         LEFT JOIN movie_screening ms ON m.movieid = ms.movieid AND ms.date >= (CURRENT_DATE - '6 mons'::interval)
GROUP BY mc.categoryname;

alter table average_ticket_prices_by_category
    owner to postgres;
```

![](img/9.png)

- Zysk dla każdego filmu wraz z datą zakupu biletów

```postgresql
create view movies_revenue (title, categoryname, startdate, enddate, orderedondate, tickets_amount, revenue) as
SELECT m.title,
       mc.categoryname,
       m.startdate,
       m.enddate,
       t.orderedondate,
       COALESCE(count(t.ticketid), 0::bigint) AS tickets_amount,
       COALESCE(sum(
                        CASE
                            WHEN t.ticketid IS NOT NULL AND is_premium_place(t.seatnumber) THEN ms.pricepremium
                            WHEN t.ticketid IS NOT NULL THEN ms.pricestandard
                            ELSE 0::numeric
                            END), 0::numeric) AS revenue
FROM movies m
         JOIN movie_categories mc ON m.moviecategoryid = mc.moviecategoryid
         LEFT JOIN movie_screening ms ON m.movieid = ms.movieid
         LEFT JOIN tickets t ON ms.moviescreeningid = t.moviescreeningid
GROUP BY m.title, mc.categoryname, m.startdate, m.enddate, t.orderedondate;

alter table movies_revenue
    owner to postgres;
```

![](img/10.png)

## 5. **Procedury**

### Testowanie poprawności działania procedur będzie pokazane w sekcji niżej, na przykładach z frontendu strony

- Rezerwacja miejsca na określony seans

```postgresql
create procedure reserve_movie_screening_seat(IN p_customer_id integer, IN p_seat_number integer, IN p_movie_screening_id integer, IN p_curr_date date, IN p_curr_time time without time zone)
    language plpgsql
as
$$
BEGIN
    IF exists(select *
              from occupied_seats as oc
              where oc.MovieScreeningID = p_movie_screening_id and oc.seatnumber = p_seat_number) THEN
        RAISE EXCEPTION 'The place has been already occupied';
    END IF;
    INSERT INTO tickets (customerid, moviescreeningid, seatnumber, orderedondate, orderedontime, status)
    VALUES (p_customer_id, p_movie_screening_id, p_seat_number, p_curr_date, p_curr_time, 'New');
END;
$$;

alter procedure reserve_movie_screening_seat(integer, integer, integer, date, time) owner to postgres;
```

- Zakup miejsca na określony seans

```postgresql
create procedure buy_movie_screening_seat(IN p_customer_id integer, IN p_seat_number integer, IN p_movie_screening_id integer, IN p_curr_date date, IN p_curr_time time without time zone)
    language plpgsql
as
$$
BEGIN
    IF exists(select *
              from occupied_seats as oc
              where oc.MovieScreeningID = p_movie_screening_id and oc.seatnumber = p_seat_number) THEN
        RAISE EXCEPTION 'The place has been already occupied';
    END IF;
    INSERT INTO tickets (customerid, moviescreeningid, seatnumber, orderedondate, orderedontime, status)
    VALUES (p_customer_id, p_movie_screening_id, p_seat_number, p_curr_date, p_curr_time, 'Confirmed');
END;
$$;

alter procedure buy_movie_screening_seat(integer, integer, integer, date, time) owner to postgres;

create procedure update_ticket_status(IN p_ticket_id integer, IN p_new_status character)
    language plpgsql
as
$$
BEGIN
    -- Checking the current status of the ticket
    DECLARE
        v_current_status CHAR(10);
    BEGIN
        SELECT status INTO v_current_status
        FROM tickets
        WHERE ticketid = p_ticket_id;

        -- If the current status of the ticket is "Confirmed", do not change it
        IF v_current_status = 'Confirmed' THEN
            RAISE NOTICE 'The ticket status is confirmed and cannot be changed.';
            RETURN;
        END IF;

        -- If the current status of the ticket is "New", allow changing it to "Canceled" or "Confirmed"
        IF v_current_status = 'New' THEN
            IF p_new_status = 'Canceled' OR p_new_status = 'Confirmed' THEN
                UPDATE tickets
                SET status = p_new_status
                WHERE ticketid = p_ticket_id;
                RAISE NOTICE 'Ticket status successfully updated to %.', p_new_status;
            ELSE
                RAISE NOTICE 'The ticket status can only be changed to "Canceled" or "Confirmed".';
            END IF;
        END IF;
    END;
END;
$$;

alter procedure update_ticket_status(integer, char) owner to postgres;
```

- Dodanie nowej kategorii (admin)

```postgresql
create procedure add_movie_category(IN p_categoryname character varying)
    language plpgsql
as
$$
BEGIN
    -- Insert new category into movie_categories table
    INSERT INTO movie_categories (categoryname)
    VALUES (p_categoryname);
END;
$$;

alter procedure add_movie_category(varchar) owner to postgres;

create procedure delete_movie_category(IN p_moviecategoryid integer)
    language plpgsql
as
$$
BEGIN
    -- Check if the category exists
    IF NOT EXISTS (SELECT 1 FROM movie_categories WHERE moviecategoryid = p_moviecategoryid) THEN
        RAISE EXCEPTION 'Category with id % does not exist', p_moviecategoryid;
    END IF;

    -- Check if any movie exists with this category
    IF EXISTS (SELECT 1 FROM movies WHERE moviecategoryid = p_moviecategoryid) THEN
        RAISE EXCEPTION 'Cannot delete category because there are movies associated with it';
    END IF;

    -- Delete the category
    DELETE FROM movie_categories
    WHERE moviecategoryid = p_moviecategoryid;
END;
$$;

alter procedure delete_movie_category(integer) owner to postgres;
```

- Usunięcie wybranej kategorii (admin)

```postgresql
create procedure delete_movie_category(IN p_categoryname character varying)
    language plpgsql
as
$$
DECLARE
    v_moviecategoryid integer;
BEGIN
    -- Отримати ID категорії за її назвою
    SELECT moviecategoryid INTO v_moviecategoryid
    FROM movie_categories
    WHERE categoryname = p_categoryname;

    -- Перевірка наявності категорії
    IF v_moviecategoryid IS NULL THEN
        RAISE EXCEPTION 'Category with name % does not exist', p_categoryname;
    END IF;

    -- Перевірка наявності фільмів з цією категорією
    IF EXISTS (SELECT 1 FROM movies WHERE moviecategoryid = v_moviecategoryid) THEN
        RAISE EXCEPTION 'Cannot delete category because there are movies associated with it';
    END IF;

    -- Видалення категорії
    DELETE FROM movie_categories
    WHERE moviecategoryid = v_moviecategoryid;
END;
$$;

alter procedure delete_movie_category(varchar) owner to postgres;
```

- Usunięcie wybranego filmu (admin)

```postgresql
create procedure delete_movie_by_name(IN p_movie_title text)
    language plpgsql
as
$$
BEGIN
    -- Check if movie with the given name exists
    IF NOT EXISTS (SELECT 1 FROM movies WHERE title = p_movie_title) THEN
        RAISE EXCEPTION 'Movie with name % does not exist', p_movie_title;
    END IF;

    -- Delete the movie
    DELETE FROM movies
    WHERE title = p_movie_title;
END;
$$;

alter procedure delete_movie_by_name(text) owner to postgres;
```

- Dodanie nowego filmu (admin)

```postgresql
create procedure add_movie(IN p_moviecategoryname character varying, IN p_title character varying, IN p_startdate date, IN p_enddate date, IN p_duration integer, IN p_description character varying, IN p_image bytea, IN p_director character varying, IN p_minage integer, IN p_production character varying, IN p_originallanguage character varying, IN p_rank double precision)
    language plpgsql
as
$$
DECLARE
    v_category_id INTEGER;
BEGIN
    -- Get movie category id from category name
    SELECT moviecategoryid INTO v_category_id FROM movie_categories WHERE categoryname = p_moviecategoryname;

    -- Check if category id is NULL, which means no matching category found
    IF v_category_id IS NULL THEN
        RAISE EXCEPTION 'Movie category % does not exist', p_moviecategoryname;
    END IF;

    -- Check if enddate is greater than startdate
    IF p_enddate <= p_startdate THEN
        RAISE EXCEPTION 'End date must be greater than start date';
    END IF;

    -- Check if duration is at least 30 minutes
    IF p_duration < 30 THEN
        RAISE EXCEPTION 'Duration must be at least 30 minutes';
    END IF;

    -- Check if rank is between 0 and 10
    IF p_rank < 0 OR p_rank > 10 THEN
        RAISE EXCEPTION 'Rank must be between 0 and 10';
    END IF;

    -- Check if minage is between 0 and 21
    IF p_minage < 0 OR p_minage > 21 THEN
        RAISE EXCEPTION 'Minimum age must be between 0 and 21';
    END IF;

    -- Insert the new movie into the movies table
    INSERT INTO movies (
        moviecategoryid, title, startdate, enddate, duration, description,
        image, director, minage, production, originallanguage, rank
    ) VALUES (
        v_category_id, p_title, p_startdate, p_enddate, p_duration, p_description,
        p_image, p_director, p_minage, p_production, p_originallanguage, p_rank
    );
END;
$$;

alter procedure add_movie_by_name(varchar, varchar, date, date, integer, varchar, bytea, varchar, integer, varchar, varchar, double precision) owner to postgres;
```

- Aktualizacja danych danego filmu (admin)

```postgresql
create procedure update_movie_by_name(IN p_moviecategoryname character varying, IN p_title character varying, IN p_startdate date, IN p_enddate date, IN p_duration integer, IN p_description character varying, IN p_image bytea, IN p_director character varying, IN p_minage integer, IN p_production character varying, IN p_originallanguage character varying, IN p_rank double precision)
    language plpgsql
as
$$
DECLARE
    v_movie_id INTEGER;
    v_category_id INTEGER;
BEGIN
    -- Get movie ID from title
    SELECT movieid INTO v_movie_id FROM movies WHERE title = p_title;

    -- Check if movie with the given title exists
    IF v_movie_id IS NULL THEN
        RAISE EXCEPTION 'Movie with title % does not exist', p_title;
    END IF;

    -- Get movie category id from category name
    SELECT moviecategoryid INTO v_category_id FROM movie_categories WHERE categoryname = p_moviecategoryname;

    -- Check if category name exists
    IF v_category_id IS NULL THEN
        RAISE EXCEPTION 'Movie category % does not exist', p_moviecategoryname;
    END IF;

    -- Check if end date is greater than start date
    IF p_enddate <= p_startdate THEN
        RAISE EXCEPTION 'End date must be greater than start date';
    END IF;

    -- Check if duration is at least 30 minutes
    IF p_duration < 30 THEN
        RAISE EXCEPTION 'Duration must be at least 30 minutes';
    END IF;

    -- Check if rank is between 0 and 10
    IF p_rank < 0 OR p_rank > 10 THEN
        RAISE EXCEPTION 'Rank must be between 0 and 10';
    END IF;

    -- Check if minage is between 0 and 21
    IF p_minage < 0 OR p_minage > 21 THEN
        RAISE EXCEPTION 'Minimum age must be between 0 and 21';
    END IF;

    -- Update the movie information
    UPDATE movies
    SET
        moviecategoryid = v_category_id,
        title = p_title,
        startdate = p_startdate,
        enddate = p_enddate,
        duration = p_duration,
        description = p_description,
        image = p_image,
        director = p_director,
        minage = p_minage,
        production = p_production,
        originallanguage = p_originallanguage,
        rank = p_rank
    WHERE
        movieid = v_movie_id;
END;
$$;

alter procedure update_movie_by_name(varchar, varchar, date, date, integer, varchar, bytea, varchar, integer, varchar, varchar, double precision) owner to postgres;
```

- Dodanie seansów z określonym zestawem danych na określoną liczbę dni (admin)
Są dodawane dokładnie takie same dane dla podanej liczby dni

```postgresql
create procedure add_movie_screenings_weekly(IN movie_title character varying, IN start_date date, IN start_time time without time zone, IN price_standard numeric, IN price_premium numeric, IN is_3d boolean, IN language_val character varying, IN hall_number integer, IN repeat_count integer)
    language plpgsql
as
$$
DECLARE
    movie_id integer;
    current_date_val date := start_date;
    iteration integer := 1;
BEGIN
    -- Retrieve the movie_id based on the title
    SELECT movieid INTO movie_id
    FROM movies
    WHERE title = movie_title;

    -- Check if the movie exists
    IF movie_id IS NULL THEN
        RAISE EXCEPTION 'Movie with title % does not exist', movie_title;
    END IF;

    -- Check if the repeat_count is within the valid range
    IF repeat_count < 1 OR repeat_count > 14 THEN
        RAISE EXCEPTION 'Repeat count % is out of the valid range (1-14)', repeat_count;
    END IF;

    -- Loop to add movie screenings for the specified number of repeat days
    WHILE iteration <= repeat_count LOOP
        CALL add_movie_screening(
            movie_title,
            current_date_val,
            start_time,
            price_standard,
            price_premium,
            is_3d,
            language_val,
            hall_number
        );

        -- Move to the next day
        current_date_val := current_date_val + 1;
        iteration := iteration + 1;
    END LOOP;
END;
$$;

alter procedure add_movie_screenings_weekly(varchar, date, time, numeric, numeric, boolean, varchar, integer, integer) owner to postgres;
```

- Dodanie nowego seansu dla danego filmu (admin)

```postgresql
create procedure add_movie_screening(IN title_val character varying, IN date_val date, IN start_time_val time without time zone, IN price_standard_val numeric, IN price_premium_val numeric, IN is_3d boolean, IN language_val character varying, IN hall_val integer)
    language plpgsql
as
$$
DECLARE
    movie_id integer;
    duration_val int;
    end_time_val time;
    hall_available boolean;
BEGIN
    -- Retrieve the movie_id and duration based on the title
    SELECT m.movieid, m.duration INTO movie_id, duration_val
    FROM movies m
    WHERE m.title = title_val
    AND date_val BETWEEN m.startdate AND m.enddate; -- Check if date_val is between startdate and enddate of the movie

    -- Check if the movie exists
    IF movie_id IS NULL THEN
        RAISE EXCEPTION 'Movie with title % does not exist or is not available on the specified date', title_val;
    END IF;

    -- Check if the movie hall exists
    IF NOT EXISTS (SELECT 1 FROM movie_halls WHERE hall_number = hall_val) THEN
        RAISE EXCEPTION 'Movie hall with id % does not exist', hall_val;
    END IF;

    -- Calculate the end time of the screening
    SELECT calculate_end_time(start_time_val, duration_val) INTO end_time_val;

    -- Check if the movie hall is available
    hall_available := is_moviehall_available(hall_val, date_val, start_time_val, end_time_val);
    IF NOT hall_available THEN
        RAISE EXCEPTION 'Movie hall with id % is not available for the specified time and date', hall_val;
    END IF;

    -- Insert the new movie screening record
    INSERT INTO movie_screening (movieid, date, starttime, endtime, pricestandard, pricepremium, threedimensional, language, hallnumber)
    VALUES (movie_id, date_val, start_time_val, end_time_val, price_standard_val, price_premium_val, is_3d, language_val, hall_val);
END
$$;

alter procedure add_movie_screening(varchar, date, time, numeric, numeric, boolean, varchar, integer) owner to postgres;
```

- Usunięcie wybranego seansu (admin)

```postgresql
create procedure delete_movie_screening(IN movie_title text, IN screening_date date, IN screening_time time without time zone)
    language plpgsql
as
$$
DECLARE
    screening_id INTEGER;
BEGIN
    -- Перевірка наявності показу фільму з заданими параметрами
    SELECT ms.moviescreeningid
    INTO screening_id
    FROM movie_screening ms
    JOIN movies m ON ms.movieid = m.movieid
    WHERE m.title = movie_title
      AND ms.date = screening_date
      AND ms.starttime = screening_time;

    -- Якщо показ не знайдено, викликаємо помилку
    IF NOT FOUND THEN
        RAISE EXCEPTION 'No movie screening for the movie "%", date "%", and time "%" exists', movie_title, screening_date, screening_time;
    END IF;

    -- Видалення знайденого показу
    DELETE FROM movie_screening
    WHERE moviescreeningid = screening_id;
END
$$;

alter procedure delete_movie_screening(text, date, time) owner to postgres;
```

## 6. **Funkcje**

- Wyświetlenie wszystkich seansów dla danego movie, które są grane po wskazywanym terminie

```postgresql
create function get_movie_sessions(p_title character varying, target_date date, target_time time without time zone)
    returns TABLE(moviescreeningid integer, movieid integer, date date, starttime time without time zone, pricestandard numeric, pricepremium numeric, moviehall integer, threedimensional boolean, language character varying)
    language plpgsql
as
$$
BEGIN
    RETURN QUERY
    SELECT
        movie_screening.moviescreeningid,
        movie_screening.movieid,
        movie_screening.date,
        movie_screening.starttime,
        movie_screening.pricestandard,
        movie_screening.pricepremium,
        movie_screening.hallnumber,
        movie_screening.threedimensional,
        movie_screening.language
    FROM
        movie_screening
    INNER JOIN
        movies as m on movie_screening.MovieID = m.movieid
    WHERE
        m.title = get_movie_sessions.p_title
        AND (movie_screening.date > get_movie_sessions.target_date
            OR (movie_screening.date >= get_movie_sessions.target_date AND movie_screening.starttime > get_movie_sessions.target_time));
END;
$$;

alter function get_movie_sessions(varchar, date, time) owner to postgres;
```

- Wyświetlenie wszystkich zajętych miejsc dla danego seansu

```postgresql
CREATE OR REPLACE FUNCTION get_occupied_seats(screening_id integer)
    RETURNS TABLE(seat_number integer)
    LANGUAGE plpgsql
AS
$$
BEGIN
    RETURN QUERY
    SELECT
        seatnumber AS seat_number
    FROM
        occupied_seats
    WHERE
        moviescreeningid = get_occupied_seats.screening_id;
END;
$$;

ALTER FUNCTION get_occupied_seats(integer) OWNER TO postgres;
```

- Wyświetlenie wszystkich filmów aktualnie granych w kinie

```postrgresql
create function get_current_movies(p_date date)
    returns TABLE(movieid integer, moviecategoryid integer, title character varying, startdate date, enddate date, duration integer, description character varying, image bytea, director character varying, minage integer, production character varying, originallanguage character varying, rank double precision)
    language plpgsql
as
$$
BEGIN
    RETURN QUERY
    SELECT
        m.movieid,
        m.moviecategoryid,
        m.title,
        m.startdate,
        m.enddate,
        m.duration,
        m.description,
        m.image,
        m.director,
        m.minage,
        m.production,
        m.originallanguage,
        m.rank
    FROM
        movies m
    WHERE
        m.startdate <= p_date and p_date <= m.enddate;
END;
$$;

alter function get_current_movies(date) owner to postgres;
```

- Wyświetlenie wszystkich filmów, które będą grane w przyszłości

```postgresql
create function get_upcoming_movies(p_date date)
    returns TABLE(movieid integer, moviecategoryid integer, title character varying, startdate date, enddate date, duration integer, description character varying, image bytea, director character varying, minage integer, production character varying, originallanguage character varying, rank double precision)
    language plpgsql
as
$$
BEGIN
    RETURN QUERY
    SELECT
        m.movieid,
        m.moviecategoryid,
        m.title,
        m.startdate,
        m.enddate,
        m.duration,
        m.description,
        m.image,
        m.director,
        m.minage,
        m.production,
        m.originallanguage,
        m.rank
    FROM
        movies m
    WHERE
        p_date < m.startdate;
END;
$$;

alter function get_upcoming_movies(date) owner to postgres;
```

- Sprawdzenie, czy sala jest dostępna w określonym terminie

```postgresql
create function is_moviehall_available(hall_val integer, date_val date, start_time_val time without time zone, end_time_val time without time zone) returns boolean
    language plpgsql
as
$$
DECLARE
    is_available boolean;
BEGIN
    SELECT NOT EXISTS (
        SELECT 1 FROM movie_screening
        WHERE hallnumber = hall_val
        AND date = date_val
        AND (starttime <= end_time_val AND endtime >= start_time_val)
    ) INTO is_available;

    RETURN is_available;
END;
$$;

alter function is_moviehall_available(integer, date, time, time) owner to postgres;
```

- Obliczanie end_time dla seansu (jest potrzebne do wstawienia danych w move_screenings)

```postgresql
create function calculate_end_time(start_time_param time without time zone, duration_param integer) returns time without time zone
    language plpgsql
as
$$
DECLARE
    end_time_result TIME;
BEGIN
    SELECT (start_time_param + INTERVAL '1 minute' * duration_param) INTO end_time_result;
    RETURN end_time_result;
END;
$$;

alter function calculate_end_time(time, integer) owner to postgres;
```

- Wyświetlenie terminów wszystkich seansów prowadzonych w danej sali

```postgresql
create function get_screenings_by_hall(hall_number_param integer, date_param date)
    returns TABLE(movieid integer, title character varying, starttime time without time zone, endtime time without time zone)
    language plpgsql
as
$$
BEGIN
    RETURN QUERY
    SELECT DISTINCT
        ms.movieid,
        m.title,
        ms.starttime,
        ms.endtime
    FROM
        movie_screening ms
    INNER JOIN movies m
        on ms.movieid = m.movieid
    WHERE
        ms.hallnumber = hall_number_param
        AND ms.date = date_param
    ORDER BY
        ms.starttime;
END;
$$;

alter function get_screenings_by_hall(integer, date) owner to postgres;
```

- Wyświetlenie wszystkich biletów dla danego użytkownika

```postgresql
create function get_tickets_for_user(user_id integer)
    returns TABLE(ticket_id integer, status character, date date, title character varying, start_time time without time zone, duration integer, hall_number integer, sit_number integer, price numeric, ordered_on_date date, ordered_on_time time without time zone)
    language plpgsql
as
$$
begin
    return query
    select
        t.ticketid,
        t.status,
        ms.Date,
        m.title,
        ms.StartTime,
        m.duration,
        ms.hallnumber,
        t.seatnumber,
        CASE
            WHEN is_premium_place(t.seatnumber) THEN ms.PricePremium
            ELSE ms.PriceStandard
        END AS price,
        t.orderedondate,
        t.orderedontime
    from
        tickets t
    inner join
        movie_screening as ms on t.MovieScreeningID = ms.MovieScreeningID
    inner join
        movies as m on m.movieid = ms.movieid
    where
        t.customerid = user_id
    order by date, starttime;
end;
$$;

alter function get_tickets_for_user(integer) owner to postgres;
```

- Sprawdzenie, czy dane miejsce jest mejscem z kategorii Premium (wszystkie sale mają tyle samo miejsc, ostatni rząd symbolizuje premium mejsca)

```postgresql
create function is_premium_place(place_value integer) returns boolean
    language plpgsql
as
$$
BEGIN
    IF place_value >= 1 AND place_value <= 11 THEN
        RETURN TRUE;
    ELSE
        RETURN FALSE;
    END IF;
END;
$$;

alter function is_premium_place(integer) owner to postgres;
```

- Wyświetlenie danych o filmu wraz z nazwą kategorii

```postgresql

create function get_movie_by_title(p_title character varying)
    returns TABLE(movieid integer, categoryname character varying, title character varying, startdate date, enddate date, duration integer, description character varying, image bytea, director character varying, minage integer, production character varying, originallanguage character varying, rank double precision)
    language plpgsql
as
$$
BEGIN
    RETURN QUERY
    SELECT
        m.movieid,
        mc.categoryname,
        m.title,
        m.startdate,
        m.enddate,
        m.duration,
        m.description,
        m.image,
        m.director,
        m.minage,
        m.production,
        m.originallanguage,
        m.rank
    FROM
        movies m
    INNER JOIN
        movie_categories as mc
    on m.moviecategoryid = mc.moviecategoryid
    WHERE p_title = m.title;
END;
$$;

alter function get_movie_by_title(varchar) owner to postgres;
```

- Wyświetlenie wszystkich dostępnych w danym dniu seansów wraz z nazwą filmu

```postgresql
create function get_movie_screenings_on_date(target_date date)
    returns TABLE(movie_title character varying, start_time time without time zone, hall_number integer, available_seats integer)
    language plpgsql
as
$$
BEGIN
    RETURN QUERY
    SELECT m.title, ms.starttime, ms.hallnumber, ((SELECT COUNT(*) FROM hall_seats WHERE moviehallnumber = ms.hallnumber) - COALESCE((SELECT COUNT(*) FROM tickets WHERE moviescreeningid = ms.moviescreeningid), 0))::integer AS available_seats
    FROM movies m
    INNER JOIN movie_screening ms ON m.movieid = ms.movieid
    WHERE ms.date = target_date;
END;
$$;

alter function get_movie_screenings_on_date(date) owner to postgres;
```

## 7. **Triggery**

- Zabronienie rezerwacji na seans który jest grany w najbliższe 2 godziny (możliwy jest wyłącznie ZAKUP biletu na taki seans)

```postgresql
create function check_reservation_period() returns trigger
    language plpgsql
as
$$
DECLARE
    screening_date DATE;
    screening_start_time TIME;
BEGIN
    SELECT date, starttime
    INTO screening_date, screening_start_time
    FROM movie_screening
    WHERE MovieScreeningID = NEW.MovieScreeningID;

    IF NEW.Status = 'New' and (screening_date + screening_start_time) <= (NEW.OrderedOnDate + NEW.OrderedOnTime + interval '2 hours') THEN
        RAISE EXCEPTION 'The movie screening must be later than 2 hours from the reservation time';
    END IF;

    RETURN NEW;
END;
$$;

alter function check_reservation_period() owner to postgres;
```

```postgresql
CREATE TRIGGER validate_reservation_time
    BEFORE INSERT
    ON tickets
    FOR EACH ROW
EXECUTE FUNCTION check_reservation_period();
```

## 8. **Indeksy**

## 9. **Widoki strony internetowej**

- Strona główna (home)

Na stronie są pokazane grane teraz i w przyszłości filmy, działa wyszukiwanie filmu

![](img/11.png)

- Movies

Na stronie są wyświetlane wszystkie movies dostępne teraz, oraz movies, które będą dostępne w przyszłości. Sortowanie domyślnie ustawione od daty permiery filmu. Na stronie działa wyszukiwanie po nazwie filmu, filtrowanie po kategorii, sortowanie według zadanych parametrów

![](img/12.png)

- Movie

Strona wybranego filmu, gdzie są wyświetlane informację dotyczące danego filmu wraz z kategorią. Jest możliwość przeglądania dostępnych w ciągu przyszłych 7 dni terminów seansów i przejście do strony danego seansu (opisana niżej)

![](img/13.png)

- Showtime

Strona wybranego seansu filmu, gdzie są wyświetlane informację dotyczące danego seansu. Klient ma możliwość podglądu zajętych miejsc na dany senas (są zaznaczone na szaro), oraz wyboru miejsca wśród Standard (12-84) albo Premium (1-11) miejsc, które też są zaznaczone różnymi kolorami i mają różne ceny

Początkowy wygląd strony:

![](img/14.png)

Wygląd strony po kliknięciu na miejsce:

![](img/15.png)

- UserProfile

Strona profilu użytkownika, gdzie są 2 przełączniki pomiędzy ticketami i ustawieniami. W zakładce "My tickets" są wyświetlane wszystkie tickety klienta wraz z informacją o seansie. W contenerze biletów, mających status "New", jest możliwość zakupu danego biletu lub jego anulowania. W zakładce "Settings" istnieje możliwość zmiany hasła użytkownika (na razie nie zrealizowana technicznie)

![](img/16.png)

![](img/17.png)

- Login & Register

Na razie logowanie i rejestracja działają na poziomie bazy danych (pojawiają się odpowiednie dane w tabelu userów), natomiast w tym momencie nie działa ustawienie sesji użytkownika

![](img/18.png)

![](img/19.png)

- Admin

Strona posiada 3 przełączniki: "View Data" - podgląd danych z tabel, "Data manager" - zarządzanie danymi tabel (dodawanie rekordów, ich modyfikacja oraz usunięcie), "Data analysis" - podgląd statystycznych danych bez możliwości modyfikacji (wywołania widoku lub funkcji, niektóre mają parametry, a niektóre nie).

### View Data

![](img/20.png)

Categories:

![](img/21.png)

Movies:

![](img/22.png)

![](img/23.png)

MovieScreenings:

![](img/24.png)

![](img/25.png)

### Data manager

![](img/26.png)

Przykładowo - Add Week-Templated Movie Screenings:

![](img/27.png)

### Data analysis

![](img/28.png)

Show Movie Screenings by Hall:

![](img/29.png)

Show revenue for Movie on OrderDate:

![](img/30.png)

Show average prices per category over past/upcoming 6 months:

![](img/31.png)

Show today Movie Screenings:

![](img/32.png)

## 10. **Testowanie poprawności działania procedur na stronie**

coming soon...............................................